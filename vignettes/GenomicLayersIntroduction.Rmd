---
title: "An introduction to the GenomicLayers package"
author: "Dave T. Gerrard"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An introduction to the GenomicLayers package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



This will be an introductory vignette on how and why to use GenomicLayers.

### Introduction



### Installation

You may have already done this but if not, you can install the _GenomicLayers_ package direct from GitHub if you have already have the _devtools_ package installed and working. For _devtools_ see here: ...

If you already have _devtools_, then the following commands should install _GenomicLayers_:-

```{r install-coms, echo=FALSE}

```



### Set up the target sequence or genome
Load the Biostrings library (this command outputs a lot of information, which is hidden here). 

```{r load_libs, echo=TRUE, message=FALSE}
library(Biostrings)

```

This can be based on a single DNA sequence or on a entire genome. If the latter, it must be loaded as a BSgenome object.  See ...

_GenomicLayers_ is designed to work on whole eukaryotic genomes including human and mouse but as these are rather large, for the purpose of demonstration we will use a shorter sequence as an example.  The SacCer chr1 is included in the _Biostrings_ package, which should have been installed along with _GenomicLayers_

```{r load-yeast, echo=TRUE}
data("yeastSEQCHR1")   # from Biostrings package
class(yeastSEQCHR1)
nchar(yeastSEQCHR1)
targetSeq <- DNAString(yeastSEQCHR1)
targetSeq 
```
The chromosome is now stored as a _DNAString_ object, which gives us access to a range of pattern searching functions provided by the _Biostrings_ package.

To use larger sequences and genomes comprised of multiple chromosomes we expect users to make use of the Bioconductor BSgenome packages. For more on this, see the section __Using larger genomes__ below.


### Create some layers on our sequence.

This is where we use the sequence and build some layers on it. 

```{r new_layers, echo=TRUE}
library(GenomicLayers)
layers1 <- createLayerList.DNAstring(targetSeq, layerNames=c("recruiter","promoter"))
layers1
```

### Create some binding factors  

This is where we specify some binding factors that can bind to the sequence and, optionally, modify the layers (but not the sequence).

If you want to learn about pattern matching against DNA sequences, we recommend that you check out the vignettes in the Biostrings package. Perhaps also have a look at PWMenrich, MOTIV etc.

We first create a binding factor that can recognise a DNA motif for at TATA box, we'll call it tata-box and then test it agains the layerSet object we've already created. It should create an IRanges or hits object with the locations or all matches to the sequence TATAA.

```{r new_bf1}
bf1 <- createBindingFactor.DNA_motif(name="tata-box", patternString = "TATAA", profile.layers=NULL, mod.layers="recruiter",mod.marks=1) 
#print(bf1)
matchBindingFactor(layerSet=layers1$layerSet, bindingFactor=bf1)
```

Then create a second binding factor that does not recognise a particular sequence, but which can bind to marks on the layer called 'recruiter'. If we test this binding factor, it should produce a hits object with no hits.

```{r new_bf2}
bf2 <- createBindingFactor.layer_region(name="tata-box", profile.layers="recruiter",profile.marks=1,                                                                        mod.layers="promoter",mod.marks=1,  patternLength = 5) 
#print(bf2)
matchBindingFactor(layerSet=layers1$layerSet, bindingFactor=bf2)
```

To use multiple binding factors together in a sequence, we add them into a named list. IMPORTANT: currently, this list must have names, so typically we specify the names when building the list. Then list names do not have to agree with the $name property of the individual binding factors (this allows the same binding factor to be re-used without re-specifying the model).

(Also, nicer formatting for binding factors when printing)
```{r bf_list}
bf_list <- list(bf1=bf1, bf2=bf2)
#print.bfSet(list(bf1))  # not working in package. FIX this .
```

### Run a sequence of layer binding

Run a simulation and collect the output

```{r run_lb}
modLayers <- runLayerBinding(layerList=layers1, factorSet=bf_list, verbose=TRUE, iter=100)
modLayers

```

Hopefully, the layer called 'promoter' should now be marked in some places.

```{r inspect_lb}

modLayers$layerSet[['promoter']]

```

### Visualise the results

What happened in the simulation?  




### Using larger genomes

Get to know the BSgenome packages....

